<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[dsa_notes]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://mushrifah.github.io/Machine-Learning-Notes/</link><image><url>https://mushrifah.github.io/Machine-Learning-Notes/site-lib/media/favicon.png</url><title>dsa_notes</title><link>https://mushrifah.github.io/Machine-Learning-Notes/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 04 Aug 2025 06:59:46 GMT</lastBuildDate><atom:link href="https://mushrifah.github.io/Machine-Learning-Notes/site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 04 Aug 2025 06:59:46 GMT</pubDate><copyright><![CDATA[Mushrifah]]></copyright><ttl>60</ttl><dc:creator>Mushrifah</dc:creator><item><title><![CDATA[3630. Partition Array for Maximum XOR and AND]]></title><description><![CDATA[<a href=".?query=tag:leetcode" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#leetcode">#leetcode</a> <a href=".?query=tag:hard" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#hard">#hard</a>Company-&gt; Problem Name -&gt; 3630. Partition Array for Maximum XOR and AND<br>
Link -&gt; <a rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/partition-array-for-maximum-xor-and-and/description/" target="_self">https://leetcode.com/problems/partition-array-for-maximum-xor-and-and/description/</a>You are given an integer array&nbsp;nums.Partition the array into&nbsp;three&nbsp;(possibly empty) subsequences&nbsp;A,&nbsp;B, and&nbsp;C&nbsp;such that every element of&nbsp;nums&nbsp;belongs to&nbsp;exactly&nbsp;one subsequence.Your goal is to&nbsp;maximize&nbsp;the value of:&nbsp;XOR(A) + AND(B) + XOR(C)where:
XOR(arr)&nbsp;denotes the bitwise XOR of all elements in&nbsp;arr. If&nbsp;arr&nbsp;is empty, its value is defined as 0.
AND(arr)&nbsp;denotes the bitwise AND of all elements in&nbsp;arr. If&nbsp;arr&nbsp;is empty, its value is defined as 0.
Return the&nbsp;maximum&nbsp;value achievable.Note:&nbsp;If multiple partitions result in the same&nbsp;maximum&nbsp;sum, you can consider any one of them.A&nbsp;subsequence&nbsp;is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.Example 1:Input:&nbsp;nums = [2,3]Output:&nbsp;5Explanation:One optimal partition is:
A = [3], XOR(A) = 3
B = [2], AND(B) = 2
C = [], XOR(C) = 0
The maximum value of:&nbsp;XOR(A) + AND(B) + XOR(C) = 3 + 2 + 0 = 5. Thus, the answer is 5.Example 2:Input:&nbsp;nums = [1,3,2]Output:&nbsp;6Explanation:One optimal partition is:
A = [1], XOR(A) = 1
B = [2], AND(B) = 2
C = [3], XOR(C) = 3
The maximum value of:&nbsp;XOR(A) + AND(B) + XOR(C) = 1 + 2 + 3 = 6. Thus, the answer is 6.Example 3:Input:&nbsp;nums = [2,3,6,7]Output:&nbsp;15Explanation:One optimal partition is:
A = [7], XOR(A) = 7
B = [2,3], AND(B) = 2
C = [6], XOR(C) = 6
The maximum value of:&nbsp;XOR(A) + AND(B) + XOR(C) = 7 + 2 + 6 = 15. Thus, the answer is 15.Constraints:
1 &lt;= nums.length &lt;= 19
1 &lt;= nums[i] &lt;= 109
`
Time Complexity -&gt;
Space Complexity -&gt; class Solution: Time Complexity -&gt;
Space Complexity -&gt; class Solution: ]]></description><link>leetcode_qs/3630.-partition-array-for-maximum-xor-and-and.html</link><guid isPermaLink="false">Leetcode_qs/3630. Partition Array for Maximum XOR and AND.md</guid><pubDate>Mon, 04 Aug 2025 06:35:13 GMT</pubDate></item><item><title><![CDATA[313. Super Ugly Number]]></title><description><![CDATA[<a href=".?query=tag:leetcode" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#leetcode">#leetcode</a> <a href=".?query=tag:dp" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dp">#dp</a> <a href=".?query=tag:array" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#array">#array</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a>Problem -&gt; 313. Super Ugly Number<br>
Link -&gt; <a rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/super-ugly-number/description/" target="_self">https://leetcode.com/problems/super-ugly-number/description/</a>A&nbsp;super ugly number&nbsp;is a positive integer whose prime factors are in the array&nbsp;primes.Given an integer&nbsp;n&nbsp;and an array of integers&nbsp;primes, return&nbsp;the&nbsp;nth&nbsp;super ugly number.The&nbsp;nth&nbsp;super ugly number&nbsp;is&nbsp;guaranteed&nbsp;to fit in a&nbsp;32-bit&nbsp;signed integer.Example 1:Input: n = 12, primes = [2,7,13,19]
Output: 32
Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].Example 2:Input: n = 1, primes = [2,3,5]
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].Constraints:
1 &lt;= n &lt;= 105
1 &lt;= primes.length &lt;= 100
2 &lt;= primes[i] &lt;= 1000
primes[i]&nbsp;is&nbsp;guaranteed&nbsp;to be a prime number.
All the values of&nbsp;primes&nbsp;are&nbsp;unique&nbsp;and sorted in&nbsp;ascending order.
so then the ugly logic can be we start off with a n which defines the index of ugly number list value which we want and a list of primes. Every iteration we will keep on building our ugly list till size n as defined. Start with 1 and then multiply that with all elements of primes list after that take the min of the list then check if that has a prime factors value in the primes list and keep the prime number to multiply with the list as that . This will run in loop till n times we get the required ugly numberTime Complexity -&gt; O(n)
Space Complexity -&gt; O(n)class Solution: Time Complexity -&gt; O(n)
Space Complexity -&gt; O(1) -&gt; do in place digit operationsclass Solution:
]]></description><link>leetcode_qs/313.-super-ugly-number.html</link><guid isPermaLink="false">Leetcode_qs/313. Super Ugly Number.md</guid><pubDate>Mon, 21 Jul 2025 10:52:08 GMT</pubDate></item><item><title><![CDATA[57. Insert Interval]]></title><description><![CDATA[<a href=".?query=tag:leetcode" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#leetcode">#leetcode</a>Company-&gt; GoogleProblem Name -&gt; 57. Insert Interval<br>
Link -&gt; <a rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/insert-interval/description/" target="_self">https://leetcode.com/problems/insert-interval/description/</a>You are given an array of non-overlapping intervals&nbsp;intervals&nbsp;where&nbsp;intervals[i] = [starti, endi]&nbsp;represent the start and the end of the&nbsp;ith&nbsp;interval and&nbsp;intervals&nbsp;is sorted in ascending order by&nbsp;starti. You are also given an interval&nbsp;newInterval = [start, end]&nbsp;that represents the start and end of another interval.Insert&nbsp;newInterval&nbsp;into&nbsp;intervals&nbsp;such that&nbsp;intervals&nbsp;is still sorted in ascending order by&nbsp;starti&nbsp;and&nbsp;intervals&nbsp;still does not have any overlapping intervals (merge overlapping intervals if necessary).Return&nbsp;intervals&nbsp;after the insertion.Note&nbsp;that you don't need to modify&nbsp;intervals&nbsp;in-place. You can make a new array and return it.Example 1:Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output:[[1,5],[6,9]] Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
Constraints:
0 &lt;= intervals.length &lt;= 104
intervals[i].length == 2
0 &lt;= starti &lt;= endi &lt;= 105
intervals&nbsp;is sorted by&nbsp;starti&nbsp;in&nbsp;ascending&nbsp;order.
newInterval.length == 2
0 &lt;= start &lt;= end &lt;= 105
Time Complexity -&gt;
Space Complexity -&gt; class Solution: Time Complexity -&gt;
Space Complexity -&gt; class Solution: ]]></description><link>leetcode_qs/57.-insert-interval.html</link><guid isPermaLink="false">Leetcode_qs/57. Insert Interval.md</guid><pubDate>Sun, 20 Jul 2025 08:16:02 GMT</pubDate></item><item><title><![CDATA[66. Plus One]]></title><description><![CDATA[<a href=".?query=tag:leetcode" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#leetcode">#leetcode</a> <a href=".?query=tag:array" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#array">#array</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a> <a href=".?query=tag:leetcode" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#leetcode">#leetcode</a>Company-&gt; GoogleProblem -&gt; 66. Plus One<br>
Link -&gt; <a rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/plus-one/description/" target="_self">https://leetcode.com/problems/plus-one/description/</a>You are given a&nbsp;large integer&nbsp;represented as an integer array&nbsp;digits, where each&nbsp;digits[i]&nbsp;is the&nbsp;ith&nbsp;digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading&nbsp;0's.Increment the large integer by one and return&nbsp;the resulting array of digits.Example 1:Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].Example 2:Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].Example 3:Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].Constraints:
1 &lt;= digits.length &lt;= 100
0 &lt;= digits[i] &lt;= 9
digits&nbsp;does not contain any leading&nbsp;0's. lst -&gt; len(n)
combine all the list elements
convert to int(combined list elements) +1
split each digits back to listTime Complexity -&gt; O(n)
Space Complexity -&gt; O(n)class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: result = int(''.join(map(str,digits))) + 1 return list(map(int,str(result))) Time Complexity -&gt; O(n)
Space Complexity -&gt; O(1) -&gt; do in place digit operationsclass Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: m = len(digits) # get it in reverse order for i in range(m-1,-1,-1): if(digits[i]&lt;9): digits[i]+=1 return digits digits[i]=0 return [1] + digits
]]></description><link>leetcode_qs/66.-plus-one.html</link><guid isPermaLink="false">Leetcode_qs/66. Plus One.md</guid><pubDate>Sun, 20 Jul 2025 08:12:57 GMT</pubDate></item><item><title><![CDATA[231. Power of Two]]></title><description><![CDATA[<a href=".?query=tag:leetcode" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#leetcode">#leetcode</a> <a href=".?query=tag:bitmanuplation" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bitmanuplation">#bitmanuplation</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a> <a href=".?query=tag:math" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#math">#math</a> Problem -&gt; 231. Power of Two<br>
Link -&gt; <a rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/power-of-two/" target="_self">https://leetcode.com/problems/power-of-two/</a>Given an integer&nbsp;n, return&nbsp;true&nbsp;if it is a power of two. Otherwise, return&nbsp;false.An integer&nbsp;n&nbsp;is a power of two, if there exists an integer&nbsp;x&nbsp;such that&nbsp;n == 2x.Example 1:Input: n = 1
Output: true
Explanation: 20 = 1Example 2:Input: n = 16
Output: true
Explanation: 24 = 16Example 3:Input: n = 3
Output: falseConstraints:
-231 &lt;= n &lt;= 231 - 1
Follow up:&nbsp;Could you solve it without loops/recursion?initial approach was to check if even number ie n%2=0 then divide the number by 2 such that in end if it reaches 1 then it is a power of 2 else its not. Edge case add for negative number condition.Bit manipulation approach -&gt;
Power of two numbers in binary have only one bit set.
1 → 0001
2 → 0010
4 → 0100
8 → 1000
So:
n &amp; (n-1) == 0 if and only if n&gt;0 and n is power of two.
example-&gt;Time Complexity -&gt; O(log n)
Space Complexity -&gt; O(1)class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: if (n&lt;=0): return False while (n%2==0): n//=2 return n==1
Bit manipulation approachTime Complexity -&gt; O(1)
Space Complexity -&gt; O(1) class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: return n &gt; 0 and (n &amp; (n-1)) == 0
]]></description><link>leetcode_qs/231.-power-of-two.html</link><guid isPermaLink="false">Leetcode_qs/231. Power of Two.md</guid><pubDate>Sun, 20 Jul 2025 08:12:49 GMT</pubDate></item><item><title><![CDATA[326. Power of Three]]></title><description><![CDATA[<a href=".?query=tag:leetcode" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#leetcode">#leetcode</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a> <a href=".?query=tag:math" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#math">#math</a>Problem -&gt; 326. Power of Three<br>
Link -&gt; <a rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/power-of-three/" target="_self">https://leetcode.com/problems/power-of-three/</a>Given an integer&nbsp;n, return&nbsp;true&nbsp;if it is a power of three. Otherwise, return&nbsp;false.An integer&nbsp;n&nbsp;is a power of three, if there exists an integer&nbsp;x&nbsp;such that&nbsp;n == 3x.Example 1:Input: n = 27
Output: true
Explanation: 27 = 33Example 2:Input: n = 0
Output: false
Explanation: There is no x where 3x = 0.Example 3:Input: n = -1
Output: false
Explanation: There is no x where 3x = (-1).Constraints:
-231 &lt;= n &lt;= 231 - 1
Follow up:&nbsp;Could you solve it without loops/recursion?initial approach was to check if even number ie n%3=0 then divide the number by 3 such that in end if it reaches 1 then it is a power of 3 else its not. Edge case add for negative number condition.Hard-coded works only for power of three method
Check for the largest 32-bit power of 3 and use that to check for divide. The largest power of 3 within signed 32-bit int is&nbsp;3^19 = 1162261467. Since powers of 3 are closed under multiplication, any true power of 3 will divide&nbsp;3^19&nbsp;evenly.Math logic method-&gt;Time Complexity -&gt; O(log₃ n)
Space Complexity -&gt; O(1)class Solution: def isPowerOfThree(self, n: int) -&gt; bool: if(n&lt;=0): return False while(n%3==0): n//=3 return n==1
Hard-coded works only for power of three method - &gt; get the highest 32-bit power of 3 ie (3^19)class Solution: def isPowerOfThree(self, n: int) -&gt; bool: return n &gt; 0 and 1162261467 % n == 0
Math log method if we divide this by log10(3) and if it results in exact integer value that means it was a power of 3.
Use of internal python libraries for log calculationTime Complexity -&gt; O(1)
Space Complexity -&gt; O(1) import math class Solution: def isPowerOfThree(self, n: int) -&gt; bool: if(n&lt;=0): return False result = math.log10(n)/math.log10(3) return result.is_integer()
]]></description><link>leetcode_qs/326.-power-of-three.html</link><guid isPermaLink="false">Leetcode_qs/326. Power of Three.md</guid><pubDate>Sun, 20 Jul 2025 08:12:31 GMT</pubDate></item></channel></rss>